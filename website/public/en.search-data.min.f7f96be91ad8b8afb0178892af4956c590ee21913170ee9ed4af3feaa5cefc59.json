[{"id":0,"href":"/gaia/adrs/0001-use-graphql-api/","title":"0001 Use Graphql API","section":"Adrs","content":"1. Use GraphQL as the Co-op Hub Interface Protocol# Date: 2026-02-05 Status: Accepted\nContext# Project Gaia aims to build a distributed smart agriculture system where the \u0026ldquo;Co-op Hub\u0026rdquo; (the central management software) is not a black box, but a replaceable component.\nThe system faces the following requirements:\nSwappability (Resyndication): A community of farmers must be able to replace the official Go implementation of the Hub with an alternative (e.g., Rust, Elixir, Python) without breaking their existing edge devices (Farm Nodes) or client tools. Client Diversity: The system must support the official Web Dashboard (SPA) while simultaneously enabling \u0026ldquo;Headless\u0026rdquo; operation via CLI tools, mobile apps, or third-party automation scripts created by farmers. Bandwidth Constraints: Farm environments often have poor connectivity. Clients need to request exact data requirements to minimize payload size (avoiding over-fetching). Strict Contract: There must be a clear, enforceable \u0026ldquo;Constitution\u0026rdquo; that defines what a Co-op is, independent of the implementation code. Decision# We will use GraphQL as the primary API paradigm for the Co-op Hub, specifically adopting a Schema-First approach.\nWe will use the gqlgen library for the Go implementation to enforce strict typing and code generation based on the schema.\nThe GraphQL Schema (.graphql files) will reside in the shared pkg/ directory and will serve as the canonical \u0026ldquo;Contract\u0026rdquo; of the system.\nConsequences# Positive# The Schema is the Contract: The GraphQL SDL (Schema Definition Language) acts as a machine-readable \u0026ldquo;Constitution.\u0026rdquo; Any backend implementation can claim compliance by adhering to this schema. Introspection: Alternative clients can query the schema to discover capabilities dynamically, lowering the barrier for farmers building custom tools. Efficient Data Loading: Clients (especially mobile or IoT aggregators) can fetch complex nested data (e.g., Farm -\u0026gt; Nodes -\u0026gt; Sensors -\u0026gt; LastReading) in a single HTTP round-trip, which is critical for high-latency farm networks. Type Safety: Using gqlgen ensures that the Go implementation cannot drift from the defined schema. If the schema changes, the code fails to compile until the resolver is updated. Negative# Complexity: Implementing GraphQL resolvers is more complex than writing simple REST handlers. We must manage DataLoaders to prevent the \u0026ldquo;N+1 Query Problem\u0026rdquo; (performance degradation when fetching nested lists). Caching: Standard HTTP caching (CDNs, browser cache) is more difficult to implement with GraphQL than with REST. We will need to rely on client-side caching (e.g., in the SPA) or persisted queries if performance becomes an issue. Binary Data: GraphQL is poor at handling file uploads/downloads. We will likely need a side-channel REST endpoint for large binary blobs (e.g., firmware updates, logs). Compliance# The schema files must be stored in pkg/graph/schema.graphql. Any change to the API structure requires a Pull Request to the pkg module first. The apps/coop-hub build pipeline must fail if the generated Go code is out of sync with the schema. "},{"id":1,"href":"/gaia/adrs/0002-hyrid-auth/","title":"0002 Hyrid Auth","section":"Adrs","content":"2. Hybrid Authentication (mTLS + JWT) \u0026amp; Database Revocation# Date: 2026-02-05 Status: Accepted\nContext# The Co-op Hub must serve two distinct classes of clients with contradictory security requirements:\nFarm Nodes (Hardware): Unattended, low-power devices. They require zero-touch authentication. mTLS (Mutual TLS) is the ideal standard here, as it authenticates the device at the connection layer using the hardware-burned identity. Farmers \u0026amp; 3rd Party Tools (Humans/Software): Web Dashboards, Mobile Apps, and custom scripts. These clients typically cannot manage client-side certificates easily and expect standard Token-based auth (JWT) over HTTPS. The Privacy Constraint: Project Gaia enforces a \u0026ldquo;Privacy First\u0026rdquo; architecture. Data resides on the Farm Node by default. The Co-op Hub is a shared aggregation point, not a master controller. Therefore, authentication as a \u0026ldquo;Farmer\u0026rdquo; (via JWT) must not grant unrestricted access to the live Farm Node, but only to data the farmer has explicitly chosen to export/syndicate to the Hub.\nThe Conflict: Enforcing strict mTLS (tls.RequireAndVerifyClientCert) at the server level rejects all standard web clients. Additionally, maintaining an external OCSP responder contradicts the \u0026ldquo;single binary\u0026rdquo; deployment goal.\nDecision# We will implement a Dual-Path Hybrid Authentication system on a single HTTPS port with strict Data Scoping.\nTLS Configuration: The Hub will use ClientAuth: tls.VerifyClientCertIfGiven. Application-Layer Gating: We will implement a unified Authentication Middleware: Path A (Hardware): If a valid Client Certificate is present, the identity is resolved as Role: NODE. Path B (Software): If a valid JWT is present, the identity is resolved as Role: FARMER. Local Revocation: We will \u0026ldquo;blocklist\u0026rdquo; certificates using the Hub\u0026rsquo;s local database, checking serial numbers against a revocations table. Data Scoping \u0026amp; Privacy Rule# Authentication does not imply data visibility. The Hub enforces a strict separation:\nThe Hub is NOT a Proxy: The Hub API will not forward queries to the live Farm Node to fetch private data. Export-Only Access: A user authenticated as FARMER can only query data that has been previously synchronized/exported from the Node to the Hub (e.g., aggregated yields, public proposals). Private by Default: Granular sensor logs, private journals, or raw operational data remaining on the Node are cryptographically inaccessible to the Hub\u0026rsquo;s JWT scope. Detailed Flow# 1. The Revocation Check# Table: certificates (columns: serial_number, node_id, status). Logic: If cert_serial is in the local blocklist cache, abort connection (403). 2. The Identity Resolution# If Cert Valid: Context.User = { Type: \u0026quot;NODE\u0026quot;, ID: Cert.CommonName } If JWT Valid: Context.User = { Type: \u0026quot;FARMER\u0026quot;, ID: Token.Sub, Scope: \u0026quot;EXPORTED_DATA_ONLY\u0026quot; } If Neither: Context.User = { Type: \u0026quot;GUEST\u0026quot; } Consequences# Positive# Privacy Compliance: The architecture technically guarantees that the Hub cannot be used to spy on a farm\u0026rsquo;s private operations. Even if a Hub admin compromises the server, they only see data the farmer voluntarily exported. Unified Endpoint: Simplifies network config (single port) while supporting both Hardware (mTLS) and Software (JWT) clients. Zero-Infrastructure Revocation: No external OCSP responder required. Negative# Data Staleness: Since the Farmer only sees exported data, the Dashboard might show slightly outdated information compared to the live physical node. Replay Risk (JWT): Unlike mTLS, JWTs can be stolen. However, the scope of a stolen JWT is limited to public/syndicated data, not the farm\u0026rsquo;s private control systems. Compliance# All GraphQL resolvers must check the data source. If a query requires live data from a Node, it must be rejected for JWT users. The revocations cache must have a short TTL (e.g., 5 minutes). "}]